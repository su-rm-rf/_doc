# Cookie + Session登录
HTTP是无状态协议，对事务处理没有记忆功能，服务端不知道客户端是什么状态
cookie可以记录状态，存放在客户端，每次请求都带上

流程：
  登录成功之后，服务端将登录状态记录到session中，并在客户端cookie中保存sessionid，每次请求都带上
  若sessionid失效或不存在，则需要重新登录获取新的sessionid
  退出时，服务端删除对应的session信息

在古老的前后端不分离的时候，会用到这种方案

安全措施：
  使用HTTPS协议加密通信内容，以防止中间人攻击
  设置cookie的HttpOnly为true，以防止前端js获取到cookie信息
  尽量减少session的有效期，以避免session被盗用
  在前后端都验证用户身份，以防止伪造登录请求

缺点：
  安全性问题：攻击者能从cookie中获取到sessionid
    使用HTTPS协议加密通信内容，设置cookie的HttpOnly为true
  跨域问题：跨域访问无法获取cookie信息
    使用JSONP、CORS等
  扩展性问题：多台服务器共享session
    集中式的session管理方案
  性能问题：每次请求都要从服务端读取session信息
    使用缓存方案，提高访问速度
  其它问题：一些设备浏览器可能禁用cookie和session，导致无法正常登录

# Token登录
token是通过服务端生成的一串加密字符串，包含了用户身份和权限等信息，以作为客户端请求的一个令牌
首次登录后，客户端保存token，每次请求都带上

是常用的前后端分离技术方案

路程：
  登录成功之后，服务端生成token并返回给前端，保存在localStorage或sessionStorage中
  每次请求都在请求头部携带token信息，服务端校验token，若不通过则返回错误信息
  退出时，客户端要删除token信息

安全措施：
  使用HTTPS协议加密通信内容，以防止中间人攻击
  设置token的过期时间，以避免token被恶意利用
  在前后端都验证token信息，以防止伪造登录请求
  根据实际需求对token进行加密处理，以增加破解难度

  token的过期时间、密钥管理、注销等，都需要考虑安全措施

token生成方式：
  随机字符串：使用随机数生成算法，比如UUID、Snowflake等，随机分布，具有很高的安全性
  JWT = JSON Web Token 将用户身份和权限等信息编码成一个JSON对象，并通过数字签名或加密等方式进行验证和保护
    还可以用于：API认证、单点登录等
  Hash值：通过某种散列函数计算出一个hahs值，具有不可逆性和唯一性，具有很高的安全性

缺点：
  安全性问题：token存储在客户端，容易被盗用、伪造、篡改
    使用HTTPS协议加密通信，设置Token的过期时间，加密、数字签名
  线程安全问题：token无状态，不支持同步机制，可能存在线程安全问题，导致重复登录等
  扩展性问题：token存储在客户端，对于大规模分布式系统，多台服务器共享token
    集中式的token管理方案
  依赖前端处理：需要前端处理token信息的存储和发送
  token泄漏问题：token长期有效，一旦被泄露，会存在更长时间的安全风险
    对token定期更新或注销

# SSO单点登录
SSO = Single Sign-On 单点登录，是一种在多个应用程序中实现认证和授权的方法
  允许用户只登录一次，旧可以访问多个应用程序，大大提高了用户体验和工作效率

流程：
  用户在第一个应用程序登录，服务端生成token并存储在一个共享的认证数据源中，比如LDAP、数据库等
  用户访问第二个应用程序，检验是否登录，若已登录，则从共享的认证数据源中获取用户信息，生成一个新token返回给浏览器
  第二个应用程序使用相同的认证数据源来验证token
  用户访问其它应用程序时，同上

实现方式：
  基于cookie: 将token存储在cookie中，并通过同源策略共享token信息
  基于session: 将token存储在服务端session中，并通过sessionid共享token信息，需要依赖中心化的session管理系统
  认证中心: 一个专门负责处理登录请求的web服务
    应用程序检查有无token，若无则跳转到认证中心，从cookie中发现
      若未登录，则跳转到统一登录，记录登录状态，并将token写入认证中心的cookie中
      若已登录，则生成一个token拼接在目标URL后面，跳转回目标URL
    应用程序拿到token后，向认证中心确认token合法性，以防止用户伪造，确认无误后把token写入当前应用程序的cookie
    此方案相对复杂，支持跨域，扩展性好，是单点登录的标准做法
    应用程序 -> 无token -> 认证中心 -> 验证cookie -> 生成token拼接在URL后面 -> 应用程序验证token -> 正常请求
  基于OAuth: 
    OAuth协议，用于在不同域名下的应用程序之间安全的共享资源和授权访问，需要额外的授权服务器和令牌管理机制
  基于OpenID Connect: 
    在OAuth2.0协议上的扩展，用于实现用户身份验证和授权，需要额外的授权服务器和令牌管理机制

退出：
  单点注销：用户在任意一个应用程序中注销时，可以自动清除其它应用程序中的会话和相关信息
  局部注销：用户只在当前应用程序中注销，不会影响其它应用程序
  全局注销：用户在某个应用程序中注销时，可以清除所有应用程序中的会话和相关信息，需要集中式的token管理机制

缺点：
  单点故障：一旦发生故障或被攻击，会影响所有应用程序的正常运行
  安全问题：涉及到所有应用程序的身份认证和授权，一旦遭到攻击，可能导致全部的信息泄露或数据损坏
  中心化依赖：集中式的，在大规模分布式系统中，需要采用集中式的认证管理方案
  可扩展性问题：新增应用程序时，单点登录系统需要进行配置和调整
  维护成本：维护和管理成本较高

# OAuth2.0第三方登录
OAuth协议，用于在不同应用程序之间安全的共享用户资源和授权访问
第三方登录，是指用户选择第三方平台的身份认证服务来登录应用程序

OAuth2.0标准定义了4种角色：
  认证服务器：是受信任的第三方，负责颁发访问令牌
  资源服务器：
  客户端：
  资源所有者：

4种授权模式：
  授权码：最常用
  隐式
  密码
  客户端：

# 扫码登录
流程：
  客户端
  授权回调域名，扫码完成后跳转到的页面，返回微信code，基于code可以拿到微信用户信息，进行登录

# 一键登录

Redis
